package mcp

import "github.com/mark3labs/mcp-go/mcp"

// Tool definitions for all 12 Moss MCP tools.
// Addressing params (id, workspace, name) are all optional in schema;
// "exactly one addressing mode" rule is enforced by handlers via ops.ValidateAddress().

var storeToolDef = mcp.NewTool("store",
	mcp.WithDescription("Store a new context capsule (max 12K chars). Creates a distilled context snapshot for AI session handoffs."),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("capsule_text",
		mcp.Required(),
		mcp.Description("The capsule content with 6 required sections: Objective, Status, Decisions, Next actions, Key locations, Open questions"),
	),
	mcp.WithString("workspace",
		mcp.Description("Namespace for the capsule (default: 'default')"),
	),
	mcp.WithString("name",
		mcp.Description("Unique handle within workspace. Omit for unnamed capsules."),
	),
	mcp.WithString("title",
		mcp.Description("Human-readable title. Defaults to name if not provided."),
	),
	mcp.WithArray("tags",
		mcp.Description("Tags for categorization"),
		mcp.WithStringItems(),
	),
	mcp.WithString("source",
		mcp.Description("Origin identifier (e.g., session ID, file path)"),
	),
	mcp.WithString("run_id",
		mcp.Description("Orchestration run identifier for multi-agent workflows"),
	),
	mcp.WithString("phase",
		mcp.Description("Workflow phase (e.g., 'design', 'implement', 'review')"),
	),
	mcp.WithString("role",
		mcp.Description("Agent role (e.g., 'design-intent', 'qa-reviewer')"),
	),
	mcp.WithString("mode",
		mcp.Description("Collision behavior: 'error' (default) fails on name collision, 'replace' overwrites existing"),
		mcp.Enum("error", "replace"),
	),
	mcp.WithBoolean("allow_thin",
		mcp.Description("If true, skip section validation. Use sparingly for quick notes."),
	),
)

var fetchToolDef = mcp.NewTool("fetch",
	mcp.WithDescription("Fetch a single capsule by ID or name. Use exactly one addressing mode: id OR (workspace+name)."),
	mcp.WithReadOnlyHintAnnotation(true),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("id",
		mcp.Description("Capsule ID (ULID). Mutually exclusive with workspace+name."),
	),
	mcp.WithString("workspace",
		mcp.Description("Workspace namespace. Required with name."),
	),
	mcp.WithString("name",
		mcp.Description("Capsule name within workspace."),
	),
	mcp.WithBoolean("include_deleted",
		mcp.Description("Include soft-deleted capsules in lookup"),
	),
	mcp.WithBoolean("include_text",
		mcp.Description("Include capsule_text in response (default: true)"),
	),
)

var fetchManyToolDef = mcp.NewTool("fetch_many",
	mcp.WithDescription("Fetch multiple capsules in a single request. Returns partial success with items and errors arrays."),
	mcp.WithReadOnlyHintAnnotation(true),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithArray("items",
		mcp.Required(),
		mcp.Description("Array of capsule references. Each item uses id OR (workspace+name)."),
		mcp.Items(map[string]any{
			"type": "object",
			"properties": map[string]any{
				"id":        map[string]any{"type": "string", "description": "Capsule ID (ULID)"},
				"workspace": map[string]any{"type": "string", "description": "Workspace namespace"},
				"name":      map[string]any{"type": "string", "description": "Capsule name"},
			},
		}),
	),
	mcp.WithBoolean("include_text",
		mcp.Description("Include capsule_text in response (default: true)"),
	),
	mcp.WithBoolean("include_deleted",
		mcp.Description("Include soft-deleted capsules in lookup"),
	),
)

var updateToolDef = mcp.NewTool("update",
	mcp.WithDescription("Update an existing capsule. Address by id OR (workspace+name). At least one editable field required."),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("id",
		mcp.Description("Capsule ID (ULID). Mutually exclusive with workspace+name."),
	),
	mcp.WithString("workspace",
		mcp.Description("Workspace namespace. Required with name."),
	),
	mcp.WithString("name",
		mcp.Description("Capsule name within workspace."),
	),
	mcp.WithString("capsule_text",
		mcp.Description("New content (validates 6 sections unless allow_thin)"),
	),
	mcp.WithString("title",
		mcp.Description("New title"),
	),
	mcp.WithArray("tags",
		mcp.Description("New tags (replaces existing)"),
		mcp.WithStringItems(),
	),
	mcp.WithString("source",
		mcp.Description("New source identifier"),
	),
	mcp.WithString("run_id",
		mcp.Description("New orchestration run identifier"),
	),
	mcp.WithString("phase",
		mcp.Description("New workflow phase"),
	),
	mcp.WithString("role",
		mcp.Description("New agent role"),
	),
	mcp.WithBoolean("allow_thin",
		mcp.Description("If true, skip section validation for capsule_text"),
	),
)

var deleteToolDef = mcp.NewTool("delete",
	mcp.WithDescription("Soft-delete a capsule. Address by id OR (workspace+name). Can be recovered with include_deleted."),
	mcp.WithDestructiveHintAnnotation(true),
	mcp.WithString("id",
		mcp.Description("Capsule ID (ULID). Mutually exclusive with workspace+name."),
	),
	mcp.WithString("workspace",
		mcp.Description("Workspace namespace. Required with name."),
	),
	mcp.WithString("name",
		mcp.Description("Capsule name within workspace."),
	),
)

var latestToolDef = mcp.NewTool("latest",
	mcp.WithDescription("Get the most recently updated capsule in a workspace. Quick way to resume work."),
	mcp.WithReadOnlyHintAnnotation(true),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("workspace",
		mcp.Description("Workspace namespace (default: 'default')"),
	),
	mcp.WithString("run_id",
		mcp.Description("Filter by orchestration run ID"),
	),
	mcp.WithString("phase",
		mcp.Description("Filter by workflow phase"),
	),
	mcp.WithString("role",
		mcp.Description("Filter by agent role"),
	),
	mcp.WithBoolean("include_text",
		mcp.Description("Include capsule_text in response (default: false for summary)"),
	),
	mcp.WithBoolean("include_deleted",
		mcp.Description("Include soft-deleted capsules in lookup"),
	),
)

var listToolDef = mcp.NewTool("list",
	mcp.WithDescription("List capsule summaries in a workspace with pagination. Sorted by updated_at descending."),
	mcp.WithReadOnlyHintAnnotation(true),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("workspace",
		mcp.Description("Workspace namespace (default: 'default')"),
	),
	mcp.WithString("run_id",
		mcp.Description("Filter by orchestration run ID"),
	),
	mcp.WithString("phase",
		mcp.Description("Filter by workflow phase"),
	),
	mcp.WithString("role",
		mcp.Description("Filter by agent role"),
	),
	mcp.WithNumber("limit",
		mcp.Description("Max items to return (default: 20, max: 100)"),
	),
	mcp.WithNumber("offset",
		mcp.Description("Skip first N items for pagination"),
	),
	mcp.WithBoolean("include_deleted",
		mcp.Description("Include soft-deleted capsules"),
	),
)

var inventoryToolDef = mcp.NewTool("inventory",
	mcp.WithDescription("List capsule summaries across all workspaces with optional filters. Use for discovery and search."),
	mcp.WithReadOnlyHintAnnotation(true),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("workspace",
		mcp.Description("Filter by workspace"),
	),
	mcp.WithString("tag",
		mcp.Description("Filter by tag"),
	),
	mcp.WithString("name_prefix",
		mcp.Description("Filter by name prefix (normalized)"),
	),
	mcp.WithString("run_id",
		mcp.Description("Filter by orchestration run ID"),
	),
	mcp.WithString("phase",
		mcp.Description("Filter by workflow phase"),
	),
	mcp.WithString("role",
		mcp.Description("Filter by agent role"),
	),
	mcp.WithNumber("limit",
		mcp.Description("Max items to return (default: 100, max: 500)"),
	),
	mcp.WithNumber("offset",
		mcp.Description("Skip first N items for pagination"),
	),
	mcp.WithBoolean("include_deleted",
		mcp.Description("Include soft-deleted capsules"),
	),
)

var exportToolDef = mcp.NewTool("export",
	mcp.WithDescription("Export capsules to a JSONL file for backup or migration."),
	mcp.WithReadOnlyHintAnnotation(false), // Writes files to disk
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("path",
		mcp.Description("Export file path. Default: ~/.moss/exports/<workspace>-<timestamp>.jsonl"),
	),
	mcp.WithString("workspace",
		mcp.Description("Filter by workspace. Omit to export all."),
	),
	mcp.WithBoolean("include_deleted",
		mcp.Description("Include soft-deleted capsules"),
	),
)

var importToolDef = mcp.NewTool("import",
	mcp.WithDescription("Import capsules from a JSONL export file."),
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithString("path",
		mcp.Required(),
		mcp.Description("Path to JSONL export file"),
	),
	mcp.WithString("mode",
		mcp.Description("Collision handling: 'error' (default, atomic), 'replace' (overwrite), 'rename' (auto-suffix)"),
		mcp.Enum("error", "replace", "rename"),
	),
)

var purgeToolDef = mcp.NewTool("purge",
	mcp.WithDescription("Permanently delete soft-deleted capsules. Irreversible."),
	mcp.WithDestructiveHintAnnotation(true),
	mcp.WithString("workspace",
		mcp.Description("Filter by workspace. Omit to purge all."),
	),
	mcp.WithNumber("older_than_days",
		mcp.Description("Only purge capsules deleted more than N days ago"),
	),
)

var composeToolDef = mcp.NewTool("compose",
	mcp.WithDescription("Assemble multiple capsules into a single bundle. All-or-nothing: fails if any capsule is missing."),
	mcp.WithReadOnlyHintAnnotation(false), // May write if store_as provided
	mcp.WithDestructiveHintAnnotation(false),
	mcp.WithArray("items",
		mcp.Required(),
		mcp.Description("Ordered list of capsule references. Each item uses id OR (workspace+name)."),
		mcp.Items(map[string]any{
			"type": "object",
			"properties": map[string]any{
				"id":        map[string]any{"type": "string", "description": "Capsule ID (ULID)"},
				"workspace": map[string]any{"type": "string", "description": "Workspace namespace"},
				"name":      map[string]any{"type": "string", "description": "Capsule name"},
			},
		}),
	),
	mcp.WithString("format",
		mcp.Description("Output format: 'markdown' (default) or 'json'"),
		mcp.Enum("markdown", "json"),
	),
	mcp.WithObject("store_as",
		mcp.Description("Optional: persist the composed bundle as a new capsule. Requires format:'markdown' (JSON lacks section headers for lint)."),
		mcp.Properties(map[string]any{
			"workspace": map[string]any{"type": "string", "description": "Target workspace (default: 'default')"},
			"name":      map[string]any{"type": "string", "description": "Capsule name (required)"},
			"mode":      map[string]any{"type": "string", "enum": []string{"error", "replace"}, "description": "Collision behavior: 'error' (default) or 'replace'"},
		}),
	),
)
